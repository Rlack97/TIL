# 배열 2

강의 주차: 5주차
복습: No
유형: algorithm
작성일시: 2022년 8월 10일 오전 8:32

## 배열 : 2차원 배열

### 2차원 배열의 선언

- 1차원 리스트를 묶어놓은 리스트
- 2차원 이상의 다차원 리스트는 차원에 따라 인덱스를 선언
- 2차원 리스트의 선언 : 세로길이(행의 개수), 가로길이(열의 개수)를 필요로 함
- python에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함
- 2차원 리스트를 읽어들이는 수식
    - `arr = [list(map(int,input().split())) for _ in range(N)]` : 빈칸구분 있음
    - `arr = [list(map(int,input()) for _ in range(N)]` : 빈칸 없음
        - `list(map(int,input()))` = 리스트 한 줄을 읽음
        - `for _ in range(N)` = 줄의 갯수만큼 이를 반복함

### 배열순회

- n X m배열의 n*m개의 모든 원소를 빠짐없지 조사하는 방법
- 행 우선 순회
    
    ```python
    #가로줄을 하나씩 읽어들이는 행 우선 순회
    for i in range(n):
    	for j in range(m):
    		Array[i][j]
    # 2차원 배열의 모든 원소에 대한 필요한 연산 수행
    ```
    
- 열 우선 순회
    
    ```python
    # 세로줄을 하나씩 읽어들이는 행 우선 순회
    for j in range(m):
    	for i in range(n):
    		Array[j][i]
    ```
    
- 지그재그 순회
    
    ```python
    for i in range(n):
    	for j in range(m):
    		Array[i][j+(m-1-2*j)*(i%2)]
    # 행 우선 순회가 기준이지만, 행이 바뀔때마다 읽어들이는 방향을 바꾸는 방식
    # j가 증가할 때 실제 인덱스값을 감소시키면 된다. m-1-j
    # i%2 = 짝수면 0이므로 정방향, 홀수이면 1이므로 역방향
    ```
    
- 델타를 이용한 2차 배열 탐색
    - 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
    - = 한 칸의 상,하,좌,우 원소를 확인하는 방식
    
    ```python
    # 현재의 좌표는 (i,j)
    arr[0...N-1][0...N-1]
    di[] = [0,0,-1,1]     # 상하좌우 
    dj[] = [1,-1,0,0]
    for i in range(N):
     for j in range(N):
    		for k in range(4):
    			ni = i + ji[k] 
    			nj = j + dj[k] 
    			if 0<= ni < N and 0 <= nj < M: # 실제로 유효한 인덱스 (이웃칸이 존재하는가?) 검증
    				arr[ni][nj]  #에 대한 연산을 진행하면 된다
    
    # 또는
    	for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]:
    	ni, nj = i +di, j + dj
    		if 0<= ni < N and 0 <= nj < M :
    			print(ni,nj)			
    
    # 칸 수를 2칸으로 늘리려면
    for i in range(N):
     for j in range(N):
    		for k in range(4):
    			for d in range(1,3):
    				ni = i + ji[k] * d
    				nj = j + dj[k] * d
    #이하 같음
    ```
    

### 전치 행렬

- 대각선을 기준으로 배열의 위치를 뒤집는 행렬
    
    ```python
    for i in range(3):
    	for j in range(3):
    		if i < j:
    			arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    ```
    

## 부분집합

### 예제

- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는가?
    - 예를 들어, [-7,-3,-2,5,8]에서 [-3,-2,5]가 존재하므로 참

### 생성하기

- 완전검색 기법으로 풀기 위해서는 모든 부분집합을 생성할 필요가 있다.
- 부분집합의 수
    - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n(2의 n제곱)이다.
    - 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 
    모든 원소의 적용한 경우의 수이다. 2*2*2*2*…*2 → 총 n개
- 각 원소가 부분집합에 포함되었는지를 loop를 통해 확인하고 생성하는 방법
    
    ```python
    bit[0,0,0,0]
    for i in range(2):
    	bit[0] = i              # 0번째 원소
    	for j in range(2):
    		bit[1] = j            # 1번째 원소
    		for k in range(2):
    			bit[2] = k          # 2번째 원소
    			for q in range(2):
    				bit[3] = q        # 3번째 원소
    				print_subset(bit) # 생성된 부분집합을 출력
    ```
    
- 비트 연산자
    - 비트 - 메모리에서 구분할 수 있는 정보의 최소단위
    - & : 비트 단위로 AND 연산을 한다.
        - 같은 자리의 수가 둘 다 1일때만 1을 출력
            - &뒤의 값이 0이면 0, 1이면 원본을 출력
        - i & (1<<j)
            - i의 j번째 비트가 1인지 아닌지를 검사
    - | : 비트 단위로 OR 연산을 한다.
    - << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
        - 1<<n : 2^n
            - 0번 비트에만 1이 들어 있을때, n번 왼쪽으로 옮긴다 = 2^n의 위치.
            - 원소가 n개일 경우의 모든 부분집합의 수
    - >> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
        - <<나 >>연산 이후 비어있는 칸은 0으로 채운다.
- 좀더 간단하게 부분집합을 생성하는 방법
    
    ```python
    arr = [3,6,7,1,5,4]
    n = len(arr)
    
    for i in range(1<<n):        # 1<<n : 부분 집합의 개수
    	for j in range(n):         # 원소의 수만큼 비트를 비교함
    		if i & (i<<j):           # i의 j번 비트가 1
    			print(arr[j],end=", ") # j번 원소 출력
    	print()
    print()
    ```
    

## 검색

- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
- 목적하는 탐색 키를 가진 항목을 찾는 것
- 종류
    - 순차 검색
    - 이진 검색
    - 해쉬

### 순차 검색

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
    - 가장 간단하고 직관적
    - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용
    - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상이 많으면 수행시간이 급격히 증가
    - 2가지 경우가 존재
        - 정렬된 경우
            - 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없는 것이므로 검색 종료
            - 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄어든다
        - 정렬되지 않은 경우
            - 첫 번째 원소부터 순서대로 키값이 같은 원소가 있는지 비교
            - 키값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
            - 마지막까지 찾지 못하면 실패
            - 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
                - 시간복잡도 O(n)

### 이진 검색

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 진행
- 목적 키를 찾을 때까지 이진 검색을 순환적 반복 수행함. 업다운 게임이랑 비슷
- 자료가 정렬된 상태여야 한다.
- 과정
    - 자료 중앙에 있는 원소를 고른다
    - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다
    - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행
    목표 값이 중앙 원소의 값보다 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행
    - 찾고자 하는 값을 찾을 때까지 반복
- 구현
    - 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행
    - 이진검색의 경우, 자료의 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬상태로 유지하는 작업이 별도로 필요
        
        ```python
        def binarysearch(a,N,key)
        	start = 0
        	end = N-1
        	while start <= end:
        		middel = start + end //2
        		if a[middle] == key:
        			return true
        		elif a[middle] > key:
        			end = middle -1
        		else:
        			start = middle +1
        	return false
        ```
        
    - 재귀함수를 활용해서 구현할 수도 있지만, 비효율적.

## 인덱스

- 인덱스라는 용어는 database에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조.
- 룩 업 테이블이라고도 함
- 인덱스를 저장하는데 필요한 공간은 보통보다 작다.
    - 인덱스는 키=필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문
- 배열을 사용한 인덱스
    - 대량의 데이터에 의한 성능 저하 문제를 해결하기 위함.
- 이름 / id 인덱스 배열을 만들어두고 이를 정렬하면 원본 테이블을 전부 불러오는 것에 비해 빠름

## 선택 정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 과정
    - 주어진 리스트 중 최소값을 찾는다
    - 그 값을 맨 앞과 교체
    - 맨 처음 위치를 제외하고, 나머지에 대해 같은 과정을 반복
    - 시간 복잡도O(n^2)
- 코드
    
    ```python
    def selsectionSort(a,N)
    	for i in range(N-1):
    		minIdx = i               #구간 맨 앞을 최소밗으로 가정
    		for j in range(i+1,N):    # 실제 최소값 인덱스 찾기
    			if a[minIdx] > a[j]:
    				minIdx = j
    		a[i], a[minIdx] = a[minIdx], a[i]  # 최소값을 구간 맨 앞으로
    ```
    

## 셀렉션 알고리즘

- 저장되어 있는 자료로부터 k번째로 큰, 혹은 작은 원소를 찾는 방법
    - 최소값, 최대값, 혹은 중간값을 찾는 알고리즘을 의미하기도 한다
- 과정
    - 정렬 알고리즘을 이용하여 자료 정렬하기
    - 원하는 순서에 있는 원소 가져오기
    - 사용하는 알고리즘에 따라 시간이 다르다
        - 버블 정렬 : O(n^2)
        - 카운팅 정렬 : O(n+k)
        - 선택 정렬 : O(n^2)
        - 퀵 정렬 : O(nlogn)
        - 삽입 정렬 : O(n^2)
        - 병합 정렬 : O(nlogn)
        

# 실습

```python
N = 3 # 행 
M = 4 # 열
# 0으로 초기화된 1차원 리스트, 길이 N 
my_list1 = [0]*N

#크기가 행N(세로길이)*열M(가로길이) 인 2차원 리스트
my_list2 = [[0]*M for _ in range(N)]
```

```python
# 초기화된 이차원 정사각형 리스트
N = int(input())
mylist = [list(map(int,input().split())) for _ in range(N)]

# 이차원 리스트 요소들의 합
s = 0
for i in range (N):
	for j in range (N):
		s += mylist[i][j]

# 행의 합들 중 최댓값
maxV = 0   # 최대 행의 합
for i in range(N):
	rs = 0   # 각 행의 합
	for j in range(N):
		rs += mylist[i][j]
	if maxV < rs:
		maxV = rs
print(maxV)

# 대각선 위의 원소들의 합
s = 0
for i in range (N):
	for j in range (M):
		if i == j:
			s += mylist[i][j]
# 혹은,
s = 0
for i in range(N):
	s+= mylist[i][i]

# 반대쪽 대각선은
s = 0
for i in range(N):
	s+= mylist[i][N-i-1]
```

```python
# 대각선으로 나눈 뒤, 양쪽 영역의 합 중 더 큰 것은?
# 윗부분dms i < j, 아랫부분은 i > j 인 인덱스로 나뉘어져 있다

N = int(input())
mylist = [list(map(int,input().split())) for _ in range(N)]

s1 = 0
s2 = 0 
for i in range(N):
	for j in range(N):
		if i > j:
			s1 += mylist[i][j]
		elif i < j:
			s2 += mylist[i][j]

# 대각선 방향의 값들의 합
s = 0*(2*N-1)
for i in range(N):
	for j in range(N):
		s[i+j] += mylist[i][j]
print(s)
```