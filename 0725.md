# 데이터 구조 및 활용

강의 주차: 3주차
복습: No
유형: Python
작성일시: 2022년 7월 20일 오후 4:57

## 데이터 구조 활용

- 데이터 구조를 활용하기 위해서는 메서드를 활용
    - 메서드란 클래스 내부의 정의한 함수 == 함수
    - 쉽게 설명하자면, '객체의 기능’
        
        **데이터 구조.메서드()** 형태로 활용
        
        쉽게 말하자면 **주어.동사()**
        
        ex) string.split() : 문자열. 쪼갠다.
        

# 순서가 있는 데이터 구조

## 문자열

### 문자열 조회 / 탐색 메서드

- s.find(x)
    - x의 첫 번째 위치를 반환. 없으면 -1
- s.index(x)
    - x의 첫 번째 위치를 반환. 없으면 오류
        - s(문자열) 내부에 x가 처음으로 등장하는 위치를 반환.
            - s = apple이고 x = p 라면 s.find(x)는 1이다.
            - s = apple이고 x = k 라면 s.index(x)는 오류가 발생한다.
- s.isalpha(x)
    - 알파벳 문자 여부 (유니코드 상  letter인 지)
- s.isupper(x)
    - 대문자 여부
- s.islower(x)
    - 소문자 여부
- s.istitle(x)
    - 타이틀 형식 여부

### 문자열 검증 메서드

- s.isdecimal()
    - 누가봐도 숫자라면 True.
- s.isdigit()
    - 숫자가 쓰여져 있긴 한 부호나 기호.
- s.isnumeric()
    - 숫자로 받아들여질 수 있는 표기법이나 글.

### 문자열 변경 메서드

- 기존 문자열을 바꾸는 것이 아니라  새롭게 만들어서 반환하는 것
- s.replace(old,new[,count])
    - 문자열 내 old 를 new로 바꿔서 변환.
    - count를 지정하면 해당 횟수만큼 시행.
- s.strip([chars])
    - 공백이나 특정 문자를 제거
        - lstrip = 왼쪽을 제거
        - rstrip = 오른쪽을 제거
        - 지정하지 않으면 공백 제거
- s.split(sep=None, maxsplit=-1)
    - 공백이나 특정 문자를 기준으로 분리
    - 문자열을 특정한 단위(구분자)로 나누어서 리스트로 변환.
- ‘separator’.join([iterable])
    - 구분자로 iterable을 합침
    - 리스트 요소들을 구분자들 앞뒤로 하나의 string으로 합치는 개념
    - 반복가능한 컨테이너 요소들을 구분자로 합쳐 문자열로 반환
        - iterable에 문자열이 아닌 값이 있다면 Error
- s.capitalize()
    - 가장 첫 글자를 대문자로 변경
- s.title()
    - 문자열 내 띄어쓰기 기준, 첫 글자는 대문자로, 나머지는 소문자로 변환
- s.upper()
    - 모두 대문자로 변경
- s.lower()
    - 모두 소문자로 변경
- s.swapcase()
    - 대 소문자를 서로 교체

## 리스트

### 리스트 메서드

- L.append(x)
    - 리스트 마지막에 항목 x를 추가
- L.insert(i,x)
    - 리스트 인덱스 i에 항목 x를 삽입
    - 리스트 길이보다 크면 그냥 맨 끝
- L.remove(x)
    - 리스트 안의 x들 중 가장 첫번째 항목을 제거.
    - 존재하지 않을 경우 ValueError
- L.pop()
    - 리스트 가장 오른쪽에 있는 항목을 반환 후 제거
- L.pop(i)
    - 리스트의 인덱스 i의 항목을 반환 후 제거
- L.clear()
    - 모든 항목 삭제
- L.index(x)
    - x값을 찾아 해당 index값을 반환
- L.extend(m)
    - 순회형인 m 의 모든 항목들을 리스트 끝에 추가.
    - 문자열인 경우 전부 쪼개서 들어감
- L.index(x,start,end)
    - 리스트 범위 내의 항목 안에 있는 x 중 가장 왼쪽의 인덱스를 반환
- L.reverse()
    - 리스트를 꺼꾸로 정렬. 역순 정렬하는 건 아님.
    - 반환값 없음. 원본 변경
- L.sort()
    - 원본 리스트를 정렬. 반환값 없음
    - L.sorted : 원본은 변경하지 않고 정렬된 리스트를 반환.
- L.count(x)
    - 리스트에 있는 항목 x의 갯수를 반환

## 튜플

### 튜플 관련 매서드

- 값에 영향을 미치지 않는 메서드들만 지원
- 항목을 변경하는 메서드를 제외하면 리스트와 거의 동일
    - extend는 값이 바뀌므로 지원되지 않음.
    - (확장)연산자는 재할당하기에 지원.

### 멤버십 연산자

- in과 not in
    - 뒤의 iterabel에 앞부분의 요소가 들어있는지 검증. 있냐 없냐.
    - ex ) ‘A’ in ‘Apple’
- True 혹은 False가 반환됨.

# 순서가 없는 데이터 구조

## 셋

- S.copy()
    - 셋의 얕은 복사본을 반환
- S.add(x)
    - 항목 x가 셋 S에 없다면 추가
- S.pop()
    - 셋 s 에서 랜덤하게 항목을 반환하고 항목을 제거
    - set이 비어 있을 경우 KeyError
- S.remove(x)
    - 항목 x를 셋 S에서 삭제.
    - x가 존재하지 않을 경우 KeyError
- S.discard(x)
    - 항목 x가 셋 S에 있는 경우, 항목 x를 셋S에서 삭제
    - 항목 x가 없어도 에러가 발생하지 않음
- S.update(t)
    - 셋 T에 있는 모든 항목 중 셋 S에 없는 항목을 추가
- S.clear()
    - 모든 항목 제거
- S.isdisjoint(t)
    - 셋 S가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우 , True
    - 겹치는게 하나도 없는, 서로소 관계.
- S.issubset(t)
    - 셋 s가 셋 t의 하위 셋일 경우 True.
- S.issuperset(t)
    - 셋 s가 셋 t의 상위 셋일 경우 True.

## 딕셔너리

- d.clear()
    - 모든 항목을 제거
- d.copy()
    - 딕셔너리 d의 얕은 복사본을 반환
- d.keys()
    - 딕셔너리 d의 모든 키를 담은 뷰를 반환
- d.vlaues()
    - 딕셔너리 d의 모든 값을 담은 뷰를 반환
- d.items()
    - 딕셔너리 d의모든 키-값의 쌍을 담은 뷰를 반환
- d.get(k)
    - 키 k의 값을 반환
    - 키 k가 없으면 None
- d.get(k,v)
    - 키 k의 값을 반환
    - 키 k가 없으면 V를 반환
- d.pop(k)
    - 키 k의 값을 반환하고 키가 k인 항목을 딕셔너리 d에서 삭제
    - 없을경우 keyerror
- d.pop(k,v)
    - 키 k의 값을 반환하고 키가 k인 항목을 딕셔너리 d에서 삭제
    - 없을경우 V를 반환
- d.update(key=value)
    - 해당하는 key의 value값을 덮어씁니다.

# 얕은 복사와 깊은 복사

## 복사 방법

- 할당
- 얕은 복사
- 깊은 복사

## 할당

### 대입 연산자 (=)

- 대입 연산자를 통한 복사는 해당 객체에 따른 객체 참조를 복사
- 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향
    
    ```python
    A = [1,2,3]
    B = A
    print (A,B)   # 이 경우 두 리스트 전부 [1,2,3]
    
    B[0] = x
    print(A,B)    # 두 리스트 전부 [x,2,3]이 됨.
    
    # 두 리스트가 모두 같은 주소를 공유하기 때문에, 복사본인 B를 통해 내용물을 바꾸면
    # 원본인 A의 값 역시 바뀜
    ```
    

## 얕은 복사

- slice 연산자를 활용하여 내용물을 복사
    - 같은 원소를 가진 리스트지만, 다른 주소이므로 복사본의 변경이 원본을 변경하지 않음.
    
    ```python
    A = [1,2,3]
    B = A[:]       # 그대로 슬라이싱 해서 복사
    print (A,B)    # 둘 다 [1,2,3]
    
    B[0] = 'hello'
    print(A,B)    # A는 [1,2,3], B는 ['hello',2,3]
    ```
    
- 주의사항
    - 복사하는 리스트의 원소가 주소를 참조하는 경우
        - 위의 코드에서 A[2] 가 [1,2]라면?
        - B[2][0] = 0으로 바꾸면 오리지널 A의 값이 변함

## 깊은 복사

```python
import copy
A = [1,2,['a','b']]
B = copy.deepcopy(A)          # deepcopy는 주소를 참조하는것이 아닌, 내부 주소들 전부 복사
								      			#  그만큼 부하가 증가
print(A,B)                  # 두 리스트 값이 같음

B[2][0] = 0
print(A,B) = [1,2,['a','b']]  [1,2,[0,'b']]   # 복사값만 변함
```