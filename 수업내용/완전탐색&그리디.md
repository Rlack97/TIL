# 완전탐색&그리디

강의 주차: 11주차
복습: No
유형: algorithm
작성일시: 2022년 9월 21일 오전 8:35

## 반복과 재귀

- 반복과 재귀는 유사한 작업을 수행할 수 있다.
    - 반복은 수행하는 작업이 완료될때 까지 반복
        - 루프 (for, while)
    - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
        - 호출 횟수 제한에 주의

### 반복구조

- 초기화
    - 반복되는 명령문을 실행하기 전에, 조건 검사에 사용할 변수의 초기값 설정
- 조건검사
- 명령문 실행
- 업데이트
    - 무한루프가 되지 않도록, 조건이 거짓이 되도록 변경
- EX) 선택정렬
    
    ```python
    def SelectionSort(A):
    	n = len(A)
    	for i in range(0,n-1):
    		minI = i
    		for j in range(i+1,n):
    			if A[j] < A[minI]:
    				minI[j]
    		A[minI], A[i] = A[i], A[minI] 
    ```
    

### 재귀 함수

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 재귀적 정의를 이용하여 구현
- **기본 부분**과 **유도 부분**으로 구성된다
- 반복 구조에 비해 간결하고 이해하기 쉬움
- 스택 구조를 활용하므로, 메모리 및 속도의 성능이 저하
- EX) 팩토리얼 재귀
    
    ```python
    def fact(n):
    	if n<=1:
    		return 1
    	else:
    		return n * fact(n)
    ```
    

- 입력값 n이 커질수록 재귀 알고리즘은 비효율적일 수 있다.

## 완전검색기법

- 부르트 포스 (Brute-force)
    - 문제를 해결하기 위한 간단하고 쉬운 접근법
    - 대부분의 문제에 적용 가능
    - 문제에 포함된 자료의 크기가 작다면 유용
    - 알고리즘의 효율성을 판단하기 위한 척도
- 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
- 해답을 도출한 뒤, 성능 개선을 위한 알고리즘을 사용하는 것이 좋음.
- 전형적으로 순열, 조합, 부분집합 같은 조합적인 문제들과 연관된다.

### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개중 r개를 택하는 순열 = n P r
    - nPr = n x (n-1) x (n-2) x … x (n-r-1) = n! / (n-r)!
    - nPn = n!이라고 표기하며 팩토리얼이라 부른다
- 구성 요소가 같더라도 순서가 다른 것은 다르게 취급한다.
- 다수의 알고리즘은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것
- 요소 N에 대해 N! 개의 순열들이 존재하므로 시간복잡도가 폭팔적으로 증가

**단순하게 순열을 생성하는 방법**

- {1,2,3} 을 포함하는 순열을 생성하는 함수
    
    ```python
    for i in range(1,4)
     for j in range(1,4)
    	if j != i
    		for k in range(1,4)
    			if k != i and k != j
    				print(i,j,k)
    
    # 사용하는 일은 없겠지만, 알고는 있어야 한다.
    ```
    
- 사전적 순서
    - 123 132 213 231 312 321
    - 각각의 순열들은 이전의 상태에서 두 요소를 교환하면서 생성
    - 최소 변경을 통한 생성이 가능.

**재귀 호출을 통한 순열 생성**

```python
#	p : 데이터가 저장된 배열
# k : 원소의 개수
# i : 선택된 원소의 수
p = [1,2,3,4,5]
perm(i,k)
	if i == k: # 인덱스가 원소의 개수와 같아짐 == 배열에서 벗어남
		print(p) # 즉 배열이 완성됨, 원하는 작업 수행
	else:
		for j in range(i,k):
			p[i],p[j] = p[j],p[i] # 자리를 바꿈
			perm(i+1,k)           # 다음 자리의 원소를 결정하러 이동
			p[i],p[j] = p[j],p[i] # 바꿨던 자리를 되돌려 놓음
			
```

**방문리스트를 통한 재귀**

```python
def f(i,k,r)   # k개 중에 r개만 고르는 경우
	if i == r:
		print(p)
	else:
		for j in range(k):
			if used[j] == 0: # a[j] 가 아직 사용되지 않았으면
				used[j] = 1    # 방문처리를 진행하고
				p[i] = a[j]    # p[i]는 a[j]로 결정함.
				f(i+1,k,r)       # p [i+1] 값을 결정하러 이동
				used[j] = 0    # a[j]를 다른 자리에서 쓸 수 있도록 방문 해제

N = 10
a = [i for i in range(1,N+1)]
used = [0] * N
f(0,N,3)
p = [0] *N
```

- 베이비 진 문제 → 6개짜리 순열을 만들어서, 앞뒤를 잘라서 구분하면 됨.

### 부분집합

- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것.
    - 배낭 짐싸기 등
- N개의 원소를 포함한 집합
    - 자기 자신과 공집합을 포함하면 2^n 개
    - 원소가 증가하면 부분집합은 지수함수로 증가
- 단순하게 모든 부분집합 생성하는 방법
    - 4개 원소를 포함한 집합에 대한 power set
        
        ![Untitled](%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8&%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%20db86ed56ddfe4c648e752bc355e0a646/Untitled.png)
        
        ```python
        나중에
        ```
        
- 바이너리 카운팅
    - 원소 수에 해당하는 N개의 비트열을 이용한다
    - n 번째 비트값이 1이면, 1번째 원소가 포함되었음을 의미한다.

**바이너리 카운팅을 통한 부분집합 생성(사전적 순서)**

```python
arr = [3,6,7,1,5,4]
n = len(arr)

for i in range(0,1<<n))  # range 1부터면 공집합이 제거됨
	for j in range(0,n):
		if i & (1<<j):  # j번 비트가 0이 아니면 arr[j] 가 부분집합의 원소
			print(%arr[j], end='')
		print()
```

**재귀를 통한 부분집합**

```python
def f(i,k):
	if i == k:
		#print(bit)
		for j in range(k):
			if bit[j]:
				print(arr[j], end=' ')
	else:
		bit[i] = 0
		f(i+1, k)
		bit[i] = 1
		f(i+1,k)

arr = [3,6,7]
n = len(arr)
bit = [0] * n
```

### 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합이라고 부른다
- n C r = n! / (n-r)! r!
- n C r = n-1 C r-1 + n-1 C r  ⇒ 재귀표현
- n C 0 = 1

**10개의 원소 중 3개를 고르는 조합**

```python
i<j<k일 때,

for i in range(8):
	for j in range(i+1,9):
		for k in range(j+1,10):
			print(a[i],a[j],a[k])

# 만약 N 개중에 3개라면,
for i in range(N-2):
	for j in range(i+1,N-1):
		for k in range(j+1,N):
			print(a[i],a[j],a[k])
```

재귀_ N개에서 R개를 고르는 조합

```python
def nCr(n,r,s):
# n개에서 r개를 고르는 조합. s= 선택할 수 있는 구간의 시작
	if r == 0:
		print(*comb)
	else:
		for i in range(s, n-r+1)
			comb[r-1] = A[i]
			nCr(n, r-1, i+1)
```

## 탐욕 알고리즘

- 거스름돈 줄이기 문제
    - 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄이는 방법
- 검증 없이 바로 구현하면 보통 그리디 접근
- 한번 선택된 것은 번복하지 않는다.
    - 따라서 단순하며, 제한적인 문제에서 적용된다
- 동작 과정
    - 해 선택
        - 가장 좋은 해를 선택. 가장 큰 동전으로만 거스름돈을 만든다
    - 실행 가능성 검사
        - 남은 거스름돈을 더 작은 단위의 동전으로 채운다
    - 해 검사
        - 거스름돈 액수가 모자라면 다시 1해 선택으로 돌아간다.

**배낭 짐싸기**

- 배낭에는 담을 수 있는 총 무게가 정해져 있다.
- 창고에는 여러 개의 물건들이 있고, 물건에는 무게와 값이 정해져 있다
- 배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값이 최대가 되는 물건을 담으려면?
    - S = [item1, item2…] 물건들의 집합
    - wi = item i의 무게
    - Pi = item i의 값
    - W = 배낭이 수용가능한 총 무게
        
        ![Untitled](%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8&%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%20db86ed56ddfe4c648e752bc355e0a646/Untitled%201.png)
        
        - 여기에 더해서 물건을 쪼갤 수 있냐 없냐로 유형이 나뉜다.

**완전 검색 방법**

- 모든 부분집합을 구한다
- 총무게가 W가 넘는 집합을 버리고, 나머지 중에서 값이 가장 큰 집합을 구한다
- 시간복잡도가 지수함수로 증가하므로 n이 증가하면 위험

**탐욕적 방법**

- 값이 비싼 물건부터?
- 가벼운 물건부터?
- 무게 당 값이 높은 물건부터?
    - 전부 최적해가 나오지 않음

## 활동 선택 문제

**회의실 배정하기**

- 회의는 시작 시간과 종료 시간이 있으며, 겹치는 회의는 동시에 열릴 수 없다.
- 가능한 많은 회의가 열리기 위해서는 어떻게 배정해야 할까?
    - 회의 갯수 입력
    - 시작시간과 종료시간 입력
- 서로 겹치지 않는 최대갯수의 활동들의 집합 S
- 양립 가능한 활동들의 크기가 최대가 되는 부분집합을 선택하는 문제이다.

**탐욕 기법 적용**

 1. 하위문제에서 종료 시간이 가장 빠른 활동을 선택한다

 2. 1 이후에는 공집합이 아닌 하위 문제가 등장한다.

 3. 1로 돌아가서 다시 종료 시간이 가장 빠른 활동을 선택하는 것을 반복한다.

- 종료 시간이 빠른 순서로 활동들을 정렬
    - 첫 활동을 선택
    - 그 활동의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
    - 남은 활동에 대해 이를 반복