# 큐

강의 주차: 7주차
복습: No
유형: algorithm
작성일시: 2022년 8월 24일 오전 8:19

### 큐의 특성

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구죠
- 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
- 선입 선출 구조
    - 삽입된 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.
- 연산 종류
    - 삽입
        - enQueue(item)
    - 삭제
        - deQueue()
    - 공백 상태의 큐를 생성
        - createQueu()
    - 큐가 공백 상태인지 확인
        - isEmpty()
    - 큐가 포화 상태인지 확인
        - isFull()
    - 큐의 앞쪽에서 원소를 삭제 없이 반환
        - Qpeek()
- 연산 과정
    - 공백 큐 생성 createQueue():
        - front = rear = -1
    - 원소 A 삽입 enQueue(A):
        - rear += 1, Q[rear] = A
    - 원소 반환 및 삭제
        - front +=1, Q[front] = 0
        - 프론트 = 마지막으로 꺼낸 자리
        - 리어 = 마지막으로 저장된 자리
        - 프론트 == 리어, 큐가 비어있음.

## 선형큐

- 1차원 배열을 이용한 큐
    - 큐의 크기 = 배열의 크기
    - front = 첫 번째 원소의 인덱스
    - rear = 마지막 원소의 인덱스
- 상태 표현
    - 초기상태 : front == rear = -1
    - 공백 상태 : front == rear
    - 포화 상태 : rear == n-1 (배열의 길이가 n)
- 잘못된 포화상태 인식
    - 원소의 삽입과 삭제가 반복될 경우 배열의 앞부분이 비어있음에도 포화상태로 인식함
    - 해결방법 1
        - 매 연산이 이루어질 때마다 원소를 앞으로 이동
        - 매우 느림
    - 해결방법 2
        - 1차원 배열을 사용하되, 배열과 끝을 연결하는 원형 형태를 사용

## 원형큐

- 초기 공백 상태
    - fornt = rear = 0
- 인덱스의 순환
    - 프론트와 리어의 위치가 n-1이 된 후, 논리적 순환을 통해 0으로 이동
    - 연산자 mod를 사용
    - → (rear +1) % N
    - 전체 길이로 나눈 나머지를 구하면, N에서 0으로 되돌아간다
- 공백과 포화를 구분하기 위해 front가 있는 자리는 사용하지 않고 빈자리로 둠
- front == rear 이면 비어있는 상태이지만
- front == rear+1 이어야 꽉 찬 상태

## 우선순위 큐

- 우선순위를 가진 항목들을 저장하는 큐
- 우선순위가 높은 순서대로 먼저 나가게 된다
- 적용 분야
    - 시뮬레이션 시스템
    - 네트워크 트래픽 제어
    - 운영체제의 테스크 스케줄링
- 배열을 이용한 우선순위 큐 구현
    - 삽입 및 삭제 연산 시의 재배치가 시간, 메모리를 크게 낭비
- 리스트를 이용한 우선순위 큐

## 큐의 활용 : 버퍼

- 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 데이터를 보관하는 메모리의 영역
- 버퍼링 : 버퍼를 활용하는 방식, 또는 버퍼를 채우는 동작
- 버퍼의 자료 구조
    - 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용
    - 순서대로 입/출력, 전달되는 것은 선입선출 형태의 큐가 활용
- 키보드 입력의 버퍼
    - 사용자 키보드 입력
    - 큐로 입력 정보 저장
    - 엔터 키 입력이 들어오면 선입선출 형태로 출력

## BFS

- 너비 우선 탐색
- 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
- 인접한 정점에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출인 큐를 활용

```jsx
def BFS(G,v)                # 탐색 그래프 G, 탐색 시작점 v
	visited = [0]*(n+1)       # 정점의 개수가 n일때, 방문 기록 리스트
	queue = []                # 큐 생성
	queue.append(v)           # 시작점을 큐에 삽입
	while queue:              # 큐가 비어있지 않다면
		t = queue.pop(0)        # 큐의 첫번째 원소 반환 
		if not visited[t]:      # 방문되지 않은 곳이라고 한다면
			visited[t] = True     # 방문 처리
			visited(t)            # 정점 t에서 처리할 함수
			for i in G[t]         # t와 연결된 모든 정점에 대해
				if not visitied[i]  # 방문되지 않은 곳이라면
					queue.append(i)   # 큐에 삽입
```

- 방문 리스트 초기화, Q생성, 시작점 enqueue
- dequeue(A), A 방문처리, A의 인접점 enqueue
- dequeue(B),  B 방문처리, B의 인접점 enqueue
- dequeue(C),  C 방문처리, C의 인접점 enqueue
- dequeue(D),  D 방문처리, D의 인접점 enqueue
- B를 처리할 때 enqueue를 통해 인접점이 들어왔으므로 다음은 B의 인접점을 실행
- …. 반복
- I까지 순회한다면 dequeue (I)를 통해 큐가 비게 되므로, 탐색 종료

- 그림을 놓고 손으로 따라가는 연습.

## BFS 예제

![Untitled](%E1%84%8F%E1%85%B2%2047f5ed0a35bd475a97dfafccf2fb6c19/Untitled.png)

- 해당 그래프를 BFS할 때, visit A를 처리하고 B,C,D를 입력할 때 visited 리스트를 입력

```jsx
def BFS(G,v,n)              # 탐색 그래프 G, 탐색 시작점 v
	visited = [0]*(n+1)       # 정점의 개수가 n일때, 방문 기록 리스트
	queue = []                # 큐 생성
	queue.append(v)           # 시작점을 큐에 삽입
	visited[v] = 1
	while queue:              # 큐가 비어있지 않다면
		t = queue.pop(0)        # 큐의 첫번째 원소 반환 
		visited(t)              # 정점 t에서 처리할 함수
			for i in G[t]                # t와 연결된 모든 정점에 대해
				if not visitied[i]             # 방문되지 않은 곳이라면
					queue.append(i)              # 큐에 삽입
					visited[i] = visited[t] +1   # n으로부터 1만큼 이동한 거리임을 기록
```

- 이 과정에서 상위 노드의 visited 값 +1을 visited에 저장한다면, 처리 과정에 있어서의 우선순위 그룹을 나눌 수 있다. (출발지로부터 거리가 같음)
    - 최단거리 찾기 문제에 활용 가능
    - 비상연락망? 다리를 건너 연락하는데 1분일 때, 같은 시간에 연락을 받는 사람은 최대 몇명?
        - → 우선순위가 동일한 정점들 값들의 최댓값

## 미로탐색

```jsx
dfs(i,j,N):
global answer
if maze[i][j] == 3:
	answer += 1
	return
else:
	visited[i][j] = 1
	for di, dj in[[0,1],[1,0],[0,-1],[-1,0]]:
		ni, nj = i+di, j+di
		if maze[ni][nj]!=1 and visited[ni][nj]==0: # 벽으로 둟러쌓인 미로의 경우
			dfs(ni,nj,N)
	return

answer = 0 # 경로의 갯수
visited = [0]*N for_ in range(N)
```