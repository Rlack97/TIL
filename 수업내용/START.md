# START

강의 주차: 11주차
복습: No
유형: algorithm
작성일시: 2022년 9월 19일 오전 9:31

## SW 문제 해결

- sw문제 해결 역량이란?
    - 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
    - 언어, 라이브러리, 자료구조, 알고리즘 지식을 적재적소에 활용
    - 추상적인 기술 = 훈련이 필요
        - 상황을 인위적으로 만들어서 훈련해야 한다. 잘 정제된 추상적 문제를 제시하고, 이를 해결해 가면서 문제해결 능력을 향상시킬수 있는 훈련이 필요.
- 문제 해결 과정
    1. 문제를 읽고 이해한다
    2. 문제를 익숙한 용어로 재정의한다
    3. 어떻게 해결할지 계획을 세운다
    4. 계획을 검증한다
    5. 프로그램으로 구현한다
    6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

## 복잡도 분석

- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
    - 공간 : 연산량 대비 메모리 공간의 사용량
    - 시간 : 연산량 대비 연산 시간의 소모량
    - 효율성의 반댓말은 복잡도. 복잡도가 높으면 효율성은 저하된다.
- 시간적 복잡도 분석
    - 하드웨어, 소프트웨어 환경에 따라 처리시간이 달라진다.
        - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
        - 입출력 장비의 성능, 공유 여부
        - 프로그램 언어의 종류
        - 운영체제, 컴파일러의 종류
    - 이러한 환경적 차이로 인해 분석이 어려움
- 복잡도의 점근적 표기
    - 입력 크기에 대한 함수로 표기하는데, 다항식이기 때문에 단순한 함수인 **점근적 표기**를 사용
    - 빅오 표기
        - 복잡도의 점근적 상한 (최악의 최대치)
        - f(n)의 빅오 표기는 f(n**2)
    - 빅오메가 표기
        - 복잡도의 점근적 하한 (최선의 최저치)
        - “최소한 이만큼은 걸린다”
    - 둘 다 최고차항만, 계수 없이 취하면 된다.
- 자주 사용하는 O표기
    - O(1) : 상수 시간
    - O(logn) : 로그 시간
    - O(n) : 선형 시간
    - O(nlogn) : 로그 선형 시간
    - O(n**2) : 제곱 시간
    - O(n**3) : 세제곱 시간
    - O(n**n) : 지수 시간
- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.
    - 10억 개의 숫자를 정렬할 때, O(n**2) 알고리즘은 300년이 걸리지만 O(nlogn)은 5분이면 됨.

## 표준 입출력 방법

### Python3 표준입출력

- 입력
    - Raw값의 입력 : input()
        - 입력값을 문자열로 취급
    - Evaluated된 값을 입력 : eval(input())
        - 받은 입력값을 평가된 데이터 형으로 취급
- 파일의 내용을 표준 입력으로 읽어오는 법
    - import sys
    - sys.stdin = open(”input.txt”,”r”)

## 비트 연산

### 비트 연산자

- &
    - and 연산
- |
    - or 연산
- ^
    - XOR 연산 (같을 때만 True)
- ~
    - 모든 비트 반전
- >>
    - 피연산자(연산자 왼쪽)의 비트 열을 오른쪽으로 이동시킨다
- <<
    - 피연산자의 비트 열을 오른쪽으로 이동시킨다

- 1<<n
    - 2의 n제곱
    - 원소가 n개일 경우의 모든 부분집합의 수
    - **Powerset**(모든 부분집합)
        - 공집합과 자기 자신을 포함한 모든 부분집합
- i&(1<<j)
    - i의 j번째 비트가 1인지 아닌지를 검증하는 연산

### 엔디안

- 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법
- 빅 엔디안
    - 큰 단위가 앞으로 나옴. 네트워크에 활용
- 리틀 엔디안
    - 작은 단위가 앞으로 나옴. 데스크탑 컴퓨터에 활용

## 진수

- 2진수, 8진수, 10진수, 16진수
- 10진수 → 타 진수로 변환
    - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
    - 149)10진수 ⇒ 10010101)2진수 ⇒ 225)8진수 ⇒ 95)16진수
- 타 진수 → 10진수로 변환
    - 135)8진수 ⇒ 1*8^2 + 3*8^1 + 5*8^0 = *93
    - 소수점이 있을 때는, 진수의  지수를 -1,-2로 내려가서 계산하면 됨.
- 컴퓨터에서의 음의 정수 표현 방법
    - 1의 보수 : 부호와 절대값으로 표현된 값을, 부호비트를 제외한 나머지 비트들을 변환.
        - 숫자 -m을 m의 2^n-1에 대한 보수로 표현 ⇒ 11111…111
    - 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.
        - 숫자 -m을 m의 2^n에 대한 보수로 표현 ⇒ 1000…000
    - *보수 : 특정한 목적값이 될 수 있도록 보충해주는 수. 더하거나 빼거나.

## 실수

- 실수의 표현
- 컴퓨터는 실수를 표현하기 위해 부동소수점 표기법을 사용.
- 소수점의 위치를 고정시켜 표현하는 방식
- 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고, 밑수의 지수승으로 표현
- 1001.0011 ⇒ 1.0010011 x 2^3
- 실수를 저장하기 위한 형식
- 단정도 실수(32비트)
    - 부호 1비트 지수 8비트 가수 23비트
    - 익세스 표현법을 사용
        - 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여, 음수지수와 양수지수를 표현하는 방법
        - 255까지 있다면, 127을 0으로 두고 위아래로 128씩 표현한다.
- 배정도 실수(64비트)
    - 부호 1비트 지수 11비트 가수 52비트
        - 가수 = 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현
        - 지수 = 실제 소수점의 위치를 지수승으로 표현
- 컴퓨터는 실수를 근사적으로 표현하므로, 이진법으로 표현할 수 없는 형태는 오차를 발생시킨다.
    - 이게 쌓이면 결과가 많이 달라질 수 있음.
    - 32비트 실수형 유효자릿수 → 6자리
    - 64비트 실수형 유효자릿수 → 15자리
- 파이썬에서의 실수 표현 범위
    - 내부적으로 더 많은 비트를 사용하므로, 훨씬 넓은 범위를 표현 가능
    - 최대는 1.8 X 10^308이며 이 이상은 inf로 표현
    - 최소는 5.0 X 10^-324이며, 이 이하는 0으로 표현