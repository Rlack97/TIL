# DB/SQLite

강의 주차: 13주차
유형: DB
작성일시: 2022년 10월 4일 오후 1:17

## Database

### 데이터베이스의 등장

- 파일을 이용한 데이터 관리
    - 장점
        - 운영체제에 관계 없이 어디에서나 쉽게 사용가능
        - 이메일이나 메신저를 이용해 간편하게 전송 가능
    - 단점
        - 성능과 보안적 측면에서 한계가 명확
        - 대용량 데이터를 다루기에 적합하지 않음
        - 구조적으로 정리하기 어려움
        - 확장이 불가능한 구조
- 스프레드 시트를 이용한 데이터 관리
    - 엑셀 시트를 이용
    - 열을 통해 데이터의 유형을 지정하고 행을 통해 구체적인 데이터 값을 포함
    - 데이터베이스로 가는 길목 정도
- 데이터베이스
    - 프로그래밍 언어를 사용해 작동시킬 수 있음
    - 가장 많이 쓰이는 유형은 RDB라고 불리는 관계형 데이터베이스
    - RDB는 각각의 데이터를 테이블에 기입함
    - 쉽게 생각하자면 스프레드시트 파일들의 모음이 RDB라고 할 수 있다.
    - 데이터베이스를 조작하는 프로그램  = DBMS
        - Oracle, MySQL, SQLite 등
        - 데이터베이스를 조작하기 위해 사용하는 언어를 SQL이라고 함

### RDB

**관계형 데이터베이스(Relational Database)**

- 데이터를 테이블, 행, 열 등으로 나누어 구조화 하는 방식
- 자료를 여러 테이블로 나누어서 관리하고, 이 테이블 간 관계를 설정해 여러 데이터를 쉽게 조작
- SQL을 사용하여 조회 및 조작

> [참고] 테이블간 관계 설정
> 
> - 고객 테이블 - **고객 id**, 이름, 주소지, 배송지
> - 주문 테이블 - 주문 id, 제품명, 주문일, 배송일, 주문상태, **고객 id**
> - 외래 키를 사용하여 고객 테이블의 고객 id를 연결하여 고객과 주문을 연결할 수 있음
> - 이 관계를 통해 특정 날짜에 구매한 모든 고객에 관한 정보를 조회하거나, 배송일이 지연된 주문을 받은 고객을 파악하는 등의 액션이 가능

**RDB 기본 구조**

- 스키마
    - 데이터베이스에서 자료의 구조, 표현 방법, 관계 등 전반적인 명세를 기술한 것
    - id - integer 와 같이 해당 자료의 형태를 기록
- 테이블
    - 필드와 레코드를 사용해 조직된 데이터 요소들의 집합
    - 관계라고도 부름
    1. 필드 ( 동일한 형태의 값들 )
        - 튜플 또는 행
    2. 레코드 (한 데이터가 가진 모든 형태의 값들)
    3. PK (primary Key)
        - 기본 키
        - 각 레코드의 고유한 값
            - 각각의 데이터를 구분할 수 있는 고유값
            - 기술적으로 다른 항목과 중복될 수 없는 단일 값

**RDB의 이점**

- 데이터를 직관적으로 표현할 수 있음
- 관련한 각 데이터에 쉽게 접근할 수 있음
- 대량의 데이터도 효율적으로 관리 가능

**SQLite**

- 응용 프로그램에 파일 형식으로 넣어 사용하는 가벼운 데이터베이스
- 안드로이드, ios등에 기본 탑재
- 오픈소스
- 대규모 동시 처리 작업에는 적합하지 않음
- 어떤 환경에서도 실행 가능
- 데이터 타입이 적고, 강하지 않으므로 학습 환경에 유리.
- 장고의 기본 데이터베이스

## SQL

- Structured Query Language
- RDBMS의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어
- 많은 데이터베이스 프로그램이 SQL을 표준으로 채택함

**Commands(명령어)**

3 가지 그룹으로 분류된다.

1. **DDL**(데이터 정의)
    - 테이블과 스키마를 정의 (생성 수정 삭제) 하기 위한 명령어
2. **DML**(데이터 조작)
    - 데이터를 조작 (추가, 조회, 변경, 삭제) 하기 위한 명령어
3. **DCL**(데이터 제어)
    - 데이터의 보안, 수행제어, 사용자 권한 부여 등을 정의하기 위한 명령어

**SQL syntax**

- 모든 SQL문은 키워드로 시작하고, 하나의 문장은 세미콜론(;)으로 끝남
    - 각 SQL문을 구분하는 표준
- SQL 키워드는 대소문자를 구분하지 않음
    - 구분을 위해 대문자로 작성하는 것을 권장

> [참고] Statement & Clasue
**Statement (문)**
독립적으로 실행할 수 있는 완전한 코드 조각
clause로 구성됨

**Clause**(절)
statement의 하위단위
> 

## DDL

- 테이블 구조를 관리하는 키워드
    
    **CREATE, ALTER, DROP = 생성, 수정, 삭제**
    

**CREATE TABLE**

```sql
CREATE TABLE 테이블 이름 (
	column_1(컬럼 이름) data_type(데이터 타입) constraints(제약조건),
	column_2(컬럼 이름) data_type(데이터 타입) constraints(제약조건),
	column_3(컬럼 이름) data_type(데이터 타입) constraints(제약조건),
);
# 필드를 정의
# 들여쓰기 정도는 상관없음. 마무리에 ; 삽입
# 마지막 요소에는 , 붙이면 안됨
```

- Data Types 종류
    1. NULL
        - NULL value
        - 정보가 없거나 알 수 없음
    2. INTEGER
        - 정수
    3. REAL
        - 실수
        - 8바이트 부동소수점을 사용하는 10진수 값이 있는 실수
    4. TEXT
        - 문자 데이터
    5. BLOB (Binary Large Object)
        - 입력된 그대로 저장된 데이터 덩어리
        - 멀티미디어, 이미지 데이터 등
    6. Boolean 타입이 없으므로, 0과 1로 저장
    7. 날짜 및 시간을 저장하기 위한 타입이 없으므로, Date and Time Functions를 활용,
    text, real, integer 값 등으로 저장

**데이터 타입 인식**

- 따옴표,소수점, 지수가 없으면 INTEGER
- 따옴표로 묶이면 TEXT
- 소수점, 지수가 있으면 REAL
- 따옴표 없이 NULL 이면 NULL

**동적 타입 시스템**

- 컬럼에 선언된 데이터 타입보다, 컬럼에 저장된 값에 따라 데이터 타입이 결정되는 구조.
- 유연한 작업 수행이 가능

**타입 선호도**

- 데이터 타입 작성 시 SQLite의 5가지가 아닌 다른 데이터 타입을 선언한다면, 내부적으로 각 타입의 지정된 선호도에 따라 5가지 선호도로 인식됨

→ 다른 데이터베이스 엔진 간의 호환성을 최대화

- 정적이고 엄격한 다른 데이터베이스의 SQL문을 SQLite에서도 작동하게 하기 위함

### constraints

- 제약조건
- 입력하는 자료에 대해 제약을 정함
- 맞지 않다면 입력이 거부됨
- 데이터 무결성을 위함
    - 정확성, 일관성을 보장하기 위해 수정 시 각종 제한이 존재
- 종류
    - NOT NULL
        - NULL값을 허용하지 않음
    - UNIQUE
        - 컬럼의 모든 값이 고유해야 함
    - PRIMARY KEY
        - ID컬럼을 직접 선언할 때 사용
        - NOT NULL을 포함함
    - AUTOINCREMENT
        - 사용되지 않은 값, 이전에 삭제된 행의 값을 재사용하는 것을 방지
        - INTEGER PRIMARY KEY AUTOINCREMENT ⇒ 해당 rowid를 재사용하지 못하게 함
    - 그 외

### ALTER TABLE

- 기존 테이블의 구조를 수정
    - 테이블 이름 변경
    - 컬럼의 이름 변경
    - 새로운 컬럼 추가
        - 테이블에 기존 데이터가 존재할 경우 에러가 발생
        - 이미 저장된 데이터들은 새롭게 추가되는 컬럼에 값이 없으므로 NULL로 작성됨
        - 새로 추가된 컬럼의 NOT NULL 제약조건으로 인해 기본 값에는 추가할 수 없게 됨
        - NOT NULL DEFAULT 제약 조건을 사용하여 해결
    - 컬럼을 삭제
        - 삭제하지 못하는 경우
            - 컬럼이 다른 테이블에서 참조되는 경우
            - 외래 키 제약조건에서 사용되는 경우
            - PRIMARY KEY인 경우
            - UNIQUE 제약 조건이 있는 경우

### DROP TABLE

- 데이터베이스에서 데이블을 제거
    - 한 번에 하나의 테이블만 삭제할 수 있음
    - 실행 취소하거나 복구가 불가능
        - 각별히 주의할 필요가 있음

## DML

심플쿼리

정렬

데이터 필터링

데이터 그룹핑

데이터 변경

터미널에서 구동

```sql
sqlite3

sqlite> .open mydb.sqlite2 # 파일 열기
sqlite> .mode csv
sqlite> .import users.csv users
```

### Simple Query

- Select 문을 사용하여 간단하게 단일 테이블에서 데이터를 조회하기
- SELECT 데이터1, 데이터2 from 테이블명
    - SELECT 절에서 컬럼 또는 쉼표로 구분된 컬럼 목록을 지정
    - FROM 절에서 데이터를 가져올 테이블을 지정
    - 모든 컬럼에 대한 약칭인 *(애스터리스크) 를 사용할 수 있음

### Sorting rows

- ORDER BY 절을 사용하여 쿼리의 결과를 정렬하기
    - SELECT 문에 추가하여 결과를 정렬
    - FROM 절 뒤에 위치
    - 하나 이상의 컬럼을 기준으로 결과를 오름차순(기본), 내림차순으로 정렬 가능
    - 이를 위해 ORDER BY 절 다음에 ASC(오름차) 또는 DESC(내림차순) 키워드를 사용
    - 하나 이상의 컬럼을 정렬할 경우 첫 번째 열을 사용하여 정렬하고, 정렬값이 같을경우 두번째 정렬 기준을 사용
    - NULL은 다른 값들보다 작은 것으로 간주
    
    ```sql
    SELECT select_list FROM table_name
    ORDER BY column_1 ASC, column_2 DESC;
    ```
    

### Filtering data

**SELECT DISTINCT**

`SELECT DISTINCT select_list FROM table;`

- 조회 결과에서 중복된 행을 제거
- SELECT에서 선택적으로 사용할 수 있는 절
    - DISCTINCT 절은 SELECT 키워드 바로 뒤에 나타나야 함
    - 키워드 뒤에 컬럼 또는 컬럼 목록을 작성
    - NULL값은 중복값으로 간주
        - NULL도 하나만 남긴다.

**WHERE**

`SELECT DISTINCT select_list FROM table WHERE search_condition;`

- 검색 시 검색 조건을 지정
    - SELECT 문에서 선택적으로 사용 가능
    - FROM 절 뒤에 작성
    
    **LIKE**
    
    패턴 일치를 기반으로 데이터를 조회
    
    SELECT, DELETE, UPDATE문의 WHERE절에서 사용. 
    
    대소문자 구분 없음
    
    - 패턴 구분을 위한 두개의 와일드카드를 재공
    - %
        - 0개 이상의 문자가 올 수 있음
    - _
        - 단일 문자가 있음
    
    **IN**
    
    - 값이 목록 내부에 있는지 확인
    - NOT IN을 통해 부정형도 가능
    
    **BETWEEN**
    
    - 값이 범위 안에 있는지 테스트
    - NOT BETWEEN으로 부정 가능
    - WHERE 조건들 간의 논리연산을 통해서도 대체 가능

**LIMIT**

- 반환되는 행 수를 제한
- SELECT에서 사용 가능
- LIMIT 10; ⇒ 10개까지만 출력
    - **OFFSET**
        - 특정 지정된 위치에서부터 데이터를 조회
        - `LIMIT 10 OFFSET 10;`
        - 11번째부터 10개

### GROUPING DATA

**GROUP BY**

- 특정 그룹으로 묶인 결과를 생성
- SELECT에서 사용 가능
- WHERE 절이 포함된 경우 WHERE절 뒤에 작성
- 데이터들의 공통 값을 묶어서 결과로 나타냄
- 집계함수
    - 값 집합의 최대, 최소, 평균, 합계 및 개수를 계산
    - AVG(), COUNT(), MAX(), MIN(), SUM()
    - COUNT를 제외하면 데이터 타입이 INTEGER일때만 가능

### CHANGING DATA

**INSERT**

- 새 행을 테이블에 삽입
- INSERT INTO table (column1,column2….) VALUES (value1,…)
- 테이블 이름 뒤에 쉼표로 구분된 컬럼 목록을 추가
    - 생략하는 경우 모든 컬럼을 지정
- VALUES 키워드 뒤에 쉼표로 구분된 값 목록을 추가
    - 값 목록의 개수는 컬럼 목록의 개수와 같아야 함

**UPDATE**

- UPDATE 절 이후에 업데이트할 테이블 지정
- SET 절에서 테이블의 각 컬럼에 대해 새 값을 지정
- WHERE 절의 조건을 사용하여 업데이트할 행을 지정
    - 생략할 시, 모든 데이터를 변경

**DELETE**

- DELETE FROM 뒤에 행을 제거하려는 테이블의 이름을 지정
- WHERE 절에 검색 조건을 추가하여 제거할 행을 식별