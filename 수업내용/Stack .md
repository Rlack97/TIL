# Stack

강의 주차: 6주차
복습: No
유형: algorithm
작성일시: 2022년 8월 17일 오전 8:10

# 스택

### 스택의 특성

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
- 스택에 저장된 자료는 선행 구조를 갖는다
    - 선형 : 자료 간의 관계가 1대1 관계를 갖는다
    - 비선형 : 자료 간의 관계가 1대 N 관계를 갖는다 (트리 등)
- 스택에 자료를 삽입하거나 꺼낼 수 있다
- 가장 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 이를 후입선출이라 부른다.

### 스택의 구현

- 구현을 위한 구조와 연산
    - 자료를 선형으로 저장할 저장소
        - 배열을 사용할 수 있다
        - 저장소 자체를 스택이라고 하기도 한다
        - 마지막으로 삽입된 원소의 위치를 top이라고 한다.
    - 연산
        - 삽입 : push
            
            `list.append(item)` 을 통해 리스트의 마지막에 데이터를 삽입 (느림)
            
            ```python
            def push(item,size):   # 크기가 정해진 스택을 사용
            	global top
            	top += 1              # top을 하나 증가시키면서 저장
            	if top == size:
            		print('overflow')  # 끝까지 차면 오버플로우 출력 (디버깅 용)
            	else:
            		stack[top] = item  # top 위치의 인덱스에 입력값을 저장
            
            size = 10               # 10칸짜리 스택 선언
            stack = [0] * size
            top = -1
            
            push(10,size)
            # 혹은
            top += 1
            stack[top] = 10
            ```
            
        - 삭제 : pop
            
            ```python
            def pop() :
            	if len(list) == 0:  
            		return '언더플로우'  # 리스트가 비어있으면 언더플로우
            	else : 
            		return list.pop(-1) # 가장 마지막을 반환
            ```
            
            ```python
            def pop():
            	global top
            	if top == -1:
            		print('underflow')
            		return 0
            	else:
            		top -= 1
            		return stack[top+1]
            
            print(pop())
            
            # 또는
            if top >-1:
            	top -= 1
            	print(stack[top])
            ```
            
        - 스택이 공백인지 확인 : isEmpty
        - 스택의 top에 있는 원소를 반환하는 연산 : peek

### 응용 1: 괄호검사

- 대괄호, 중괄호, 소괄호
- 조건
    - 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 함
    - 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다
    - 괄호 사이에서는 포함 관계만 존재한다
- 스택 이용
    - 왼쪽 괄호가 나오면 스택에 넣고
    - 같은 종류의 오른쪽 괄호가 나오면 스택을 pop해서 짝을 맞춘다.
    - 검사가 끝난 후 스택이 비어 있어야지 옳은 괄호

### 응용 2: function call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
    - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출
    - 함수 호출이 발생하면 필요한 각종 변수와 주소 등의 정보를 **스택 프레임**에 저장하여 스시템 스택에 삽입
    - 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
    - 함수 호출과 복귀에 따라 이를 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백이 된다.
        
        ```python
        ################
        stack_Frame(F_2)
        F_2() 함수 실행 관련 정보          <- 현재 실행 중인 함수 top
        ################
        stack_Frame(F_1)
        F_1() 함수 실행 관련 정보
        ################
        stack_Frame(main)
        main() 함수 실행 관련 정보
        ```
        

# 재귀호출

- 자기 자신을 호출하여 순환 수행되는 것
- 프로그램의 크기를 줄이고 간단하게 작성하는 것이 가능
- 팩토리얼, 피보나치 등

### 팩토리얼

```python
fact(1) = return 1
fact(2) = 2 * fact(1) 
fact(3) = 3 * fact(2)
fact(4) = 4 * fact(3)
....
fact(n) = n * fact(n-1) # 이전 입력값의 자신을 호출
```

### 피보나치

```python
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2) # n이 2 이상일 때

def fibo(n):
	if n < 2:
		return n
	else:
		return fibo(n-1) + fibo(n-2)
```

# Memoization

- 재귀함수 구현의 문제점, **바로 엄청난 중복호출이 존재한다는 것**
- 메모이제이션은 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하는 기술.
- 동적 계획법의 핵심
- ‘메모리에 넣기’ 라는 의미
- 피보나치 알고리즘에서, 값을 계산하자마자 저장하면 실행시간을 줄일 수 있다,

```python
# 메모를 위한 배열을 할당하고 0으로 초기화
# memo[0]을 0으로, memo[1] 은 1로 초기화

def fibo1(n):
	global memo
	if n >=2 and len (memo) <= n:
		memo.append(fibo(n-1) + fibo(n-2))
	return memo[n]

memo = [0,1]

# 혹은

def fibo(n):
	if memo[n] == -1:
		memo[n] = fibo(n-1) + fibo(n-2)
	return meemo[n]

memo = [-1]*201
memo[0] = 0
memo[1] = 1
for i in range(201):
	print(i,fibo(i))
```

# DP(동적 계획)

- 그리디 알고리즘과 같이, **최적화 문제**를 해결하는 알고리즘
- 입력 크기가 작은 부분 문제들을 모두 해결한 뒤에, 이를 활용하여 큰 크기의 문제들을 해결하는 것으로 원래 주어진 문제를 해결.
- 즉, 작고 자잘한 것들부터 풀어나간다는 것.

### 피보나치의 경우

1. 문제를 부분 문제로 분할
    - F(n) 함수는 F(n-1)과 F(n-2)의 합 …..
2. 가장 작은 부분의 문제부터 해를 구한다.
3. 이를 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.
    1. 테이블 인덱스 0, 저장된 값 0
    2. 테이블 인덱스 1, 저장된 값 1 
    3. 테이블 인덱스 2, 저장된 값 1
    
    ….
    
    테이블 인덱스 n, 저장된 값 fibo(n)
    

```python
def fibo2(n):
	f = [0,1]
	
	for i in range(2, n+1):
		f.append(f[i-1]+f[i-2])

	return f[n]

# 위에서 내려가는 재귀와는 달리, 가장 아래(작은 값)에서부터 계산함.
```

### DP의 구현 방식

- recursive 방식
    - 재귀적 구조
    - 시스템 호출 스택을 사용하는 오버헤드가 발생
- iterative 방식
    - 반복적 구조
    - 성능면에서 더 효율적

# DFS (깊이우선탐색)

- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
- 두 가지 방법이 있음
    - 깊이 우선 탐색 DFS
    - 너비 우선 탐색 BFS
- 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없어지면 가장 마지막에 만났던 갈림길로 돌아와서 다른 방향으로의 탐색을 반복하여 모든 자료를 방문
- 가장 마지막에 만났던 갈림길로 돌아가서 다시 탐색하는 것이므로 **후입선출** 구조인 스택을 활용
1. 시작 정점 v를 결정하여 방문한다
2. 정점 v에 인접한 정점 중에서
    1. 방문하지 않은 정점 w가 있으면, 정점v를 스택에 push하고 정점 w를 방문
    2. 그리고 이를 반복한다.
    3. 반복하지 않은 정점이 없으면, 스택에서 pop하여 가장 마지막 방문 정점을 v로 하여 반복
3. 스택이 공백이 될 때까지 이를 반복.

### 구현

```python
# visited는 False로 초기화, stack은 빈 리스트로 초기화
DFS(v)
	visited[v]  == true: # 시작점 v를 방문했으면,
	while:
		if #인접 정점 중 방문 안한 w가 있음
			push(v):
			v <- w  # w에 방문
			visited[w] = true
		else: # 정점 전부를 방문한 경우
			if # 스택이 비어 있지 않다면 이전 정점으로 되돌아감
				v = stack.pop()
			else:
				break    
```

일단 정점을 기록하면 스택에 기록만 해두고 전진

### 인접 리스트 작성

1. index번호의 노드에 연결된 노드의 번호를 작성
    
    ex) list[0] = [1,2]  → 0번 노드에 1,2가 연결되어 있음
    
2. 간선(연결된 노드의 수) 를 기록하는 경우
    
    ex)