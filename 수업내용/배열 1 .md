# 배열 1

강의 주차: 5주차
복습: No
유형: algorithm
작성일시: 2022년 8월 8일 오전 9:42

# 알고리즘

- 알고리즘: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.
- 어떠한 문제를 해결하기 위한 절차.
- 1부터 100까지의 합?
    - 컴퓨터의 알고리즘을 표현하는 방법은 두가지
        - 의사코드 ( 수도코드)
            
            ```python
            CalcSum(n)
            	sum <- 0
            	for i : 1 -> n
            		sum <- sum + i
            	return sum;
            ```
            
        - 순서도
            
            ![Untitled](%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%201%20ea01a1481f144773a0615ced6ff1929e/Untitled.png)
            
- 무엇이 좋은 알고리즘인가?
    - 정확성 : 얼마나 정확하게 동작하는가
    - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
    - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
    - 단순성 : 얼마나 단순한가 (이해하기 좋음)
    - 최적성 : 더 이상 개선할 여지없이 최적화되었는가
- 주어진 문제를 해결하기 위해서는 여러 알고리즘을 사용할 수 있다.
    - 선택을 위해서는 알고리즘들의 성능을 분석할 필요가 있다.
        - 시간복잡도
            - 실제 걸리는 시간을 측정
            - 실행되는 명령문의 개수를 계산
            - **빅 오 표기볍**
                - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
                - O(3n+2) → 최고차항만 선택 O(3n) → 계수 제거 O(n)
                - 

## 배열

- 배열이란 무엇인가
    - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 배열의 필요성
    - 프로그램 내에서 여러 개의 변수가 필요할 때, 일일히 변수명을 지정하는 것은 비효율적
    - 하나의 선언으로 둘 이상의 변수를 선언 가능
    - 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.
- 1차원 배열의 선언
    - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
    - Arr = list(), [] , [1,2,3], [0]*10
- 1차원 배열의 접근
    - Arr[idx] = 10
        - 배열 Arr의 idx번 원소에 10을 저장

### 배열 활용 예제 : Gravity

- 상자들이 쌓여있는 방이 있다. 방이 90도 회전하여 상자들이 낙하한다면, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하시오.
- 방은 가로 세로 100 길이이다.

```python
N = int(input())
arr = list(map(int, input().split()))
maxV = arr[0] # 첫 원소를 최대값으로 가정
for i in range(1,N): # 나머지 모든 원소에 대해
	if arr[i] > maxV:
		maxV = arr[i]

cnt = 0
for i in range(0,N):
	if arr[i] == maxV:
		cnt += 1

nakcha = (100 - index(maxV) - cnt

return nakcha
--------
#거품정렬#

tmp = [0]*N
c = [0]*101 # 인덱스가 100까지 있어야 하므로 101
for i in range (N): 
	c[arr[i]] += 1  # 카운트 정렬
for j in range(1,101): #개수 누적
	c[j] += c[j-1]
for i in range(N-1,-1,-1): # 원본을 뒤에서부터 읽으면서 정렬 결과를 tmp에 저장
	c[arr[i]] -= 1
	tmp[c[arr[i]]] = arr[i]

```

## 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대로의 순서대로 재배열하는 것.
    - 키 = 자료를 정렬하는 기준이 되는 특정 값
- 정렬의 종류
    
    ### 버블 정렬
    
    - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
    - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
    - 한 단계가 끝나면 가장 큰 원소가 가장 마지막 자리에 정렬
    - 시간복잡도 : O(n^2)
    - 코드로 구현하면 다음과 같다.
        
        ```python
        BubbleSort(a,N)             # 정렬할 배열과 배열의 크기
        	for i : N-1 -> 1          # 정렬될 구간의 끝 
        		for j: 0 -> i-1         # 비교할 원소 중 왼쪽 번호의 인덱스
        			if a[j] > a [j+1]     # 왼쪽 원소가 더 크면
        				a[j] <-> a [j+1]    # 두 원소를 교환
        ```
        
        ```python
        def Bubblesort(a,N) # a는 정렬할 리스트, N은 원소 수
        	for i in range(N-1,0,-1): # 정렬할 범위의 끝 위치 (하나씩 줄어듬)
        		for j in range(0,i):    # 인접원소 중 왼쪽원소 인덱스
        			if a[j]	> a[j+1]:     # 오름차순 ( 더 큰 수가 오른쪽으로)
        				a[j], a[j+1] = a[j+1], a[j]
        ```
        
    
    ### 카운팅 정렬
    
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 알고리즘
    - 제한 사항
        - **정수나, 정수로 표현할 수 있는 자료**에 대해서만 적용 가능 - 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 떄문
        - 카운트를 위한 공간 확보를 위해 **집합 내의 가장 큰 정수**를 알아야 한다.
    - 시간복잡도
        - O(n+k) : n은 리스트 길이, k는 정수의 최대값
    1. 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
        - counts[i] = i의 발생 횟수
            - count[ arr [ i ] ] += 1 의 형태로 기록하면 된다.
    2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다. (미리 합쳐두기와 같은 형태로 계산 시간을 단축)
        - count[i] = count[i-1] + count[i]
    3. 맨 뒤의 원소부터 접근한다. Temp는 기존 데이터와 같은 길이의 배열이다.
        - count[i]을 감소시키고 Temp[count[i]]에 i을 삽입한다.
            - ex) 0과 1을 합쳐서 4개가 있으므로, 가장 뒤의 원소 1은 정렬하게 되면 4번째에 위치하기 때문.  즉 인덱스 값이 3이 된다.
    4. 순서대로 끝까지 작업 후, temp를 업데이트하고 종료
        
        
    - 코드로 구현하면 다음과 같다
        
        ```python
        def Counting_Sort(A,B,k)
        	# A = 입력 배열(1 to k) len(A) = k
          # B = 정렬된 배열 (TEMP)
          # C = 카운트 배열 (COUNT)
        	C = [0]* (k+1)
        
        	for i in range(0,len(A)):
        		C[A[i]] += 1
        
        	for i in range(1, len(C)):
        		C[i] += C[i-1]
        
        	for i in range(len(B)-1, -1, -1):
        		C[A[i]] -= 1
        		B[C[A[i]]] = A[i]
        ```
        
- 그 외에도
    - 선택 정렬
    - 퀵 정렬
    - 삽입 정렬
    - 병합 정렬

### 정렬 예제 - Baby-gin Game

- 0~9 사이의 숫자 카드에서 임의로 6장을 뽑았을때, 3장의 카드가 연속적인 번호라면 run, 3장의 카드가 동일한 번호라면 triplet이라 한다.
- 그리고 6장의 카드가 run과 triplet로만 구성되어 있다면 이를 baby-gin이라 부른다
- 6자리를 입력받아 해당 수가 baby gin인지 판단하는 프로그램을 작성하라
- 입력 예
    - 667767은 트리플릿 2개이므로 베이비진이다
    - 054060은 런 하나 트리플릿 하나이므로 베이비진이다
    - 101123은 트리플릿이 있으나, 023이 런이 아니므로 베이비진이 아니다.
        
        → 완전검색을 사용
        
- 고려할 수 있는 모든 경우의 수 생성하기
    - 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
    - 예)입력으로 235777을 받았을 경우
        - 235777,237577,237757,…, 777532
    - 앞의 3자리와 뒤의 3자리를 잘라 run과 트리플릿 여부를 테스트하고 최종적 판단

## 완전검색

- 모든 경우의 수를 나열해보고 확인하는 기법.
- 브루트 포스. 제네레이트 앤드 테스트라고도 부른다.
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
- 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적으므로 애용하자.
- 자격검정평가 등에서, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 다음과 같다, nPr
- 그리고 nPr은 다음 식이 성립한다.
    - nPr = n * (n-1) * (n-2) * … * (n-r+1)
    - nPn = n!
- 예) {1,2,3}을 포함하는 모든 순열을 생성하는 함수 (동일숫자 미포함)
    
    ```python
    for i1 in range(1,4):
    	for i2 in range(1,4):
    		if i2 != i1:
    			for i3 in range(1,4):
    				if i3! = i1 and i3 ! = i2:
    					print(i1,i2,i3)
    ```
    

## 그리디

- 탐욕 알고리즘은 ‘최적해’를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 그것이 반드시 최적이 아님.
- 그리디 알고리즘의 동작 과정
    1. 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합에 추가한다
    2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
    3. 해 검사: 새로운 부분해 집합이 문제의 해가 되는지 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1로 돌아간다
- 베이비 진 문제를 다른 방법으로 풀어보자.
    - 6개의 숫자는 6자리의 정수 값으로 입력됨.
    - counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부를 판단한다
- 풀이
    - ex)444345
        - arr = list(map(int,input()))
        - count 정렬을 진행한 후, 트리플릿을 조사.(같은 수 3개)
        - 그 후 검사에 사용한 데이터를 삭제.
        - 이후 런도 조사하면 됨.
- 구현
    
    ```python
    num =  list(map(int,input()))
    c = [0]*12        # 인덱스 에러/조건문 사용을 방지하기 위해 9 + 3을 사용
    
    for i in range(6):
    	c[num % 10] += 1 
    	num//= 10          # 각 자릿수의 값을 구하고, c에 할당하는 count 정렬
    
    i = 0
    tri = run = 0
    while i < 10:
    	if c[i] >= 3: # 트리플렛 조사 후 삭제하는 코드
    		c[i] -3
    		tri += 1
    		continue
    	if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1 : # 런 조사 후 데이터 삭제
    		c[i] -= 1
    		c[i+1] -= 1
    		c[i+2] -= 1
    		run += 1
    		continue
    	i += 1
    
    if run + tri == 2:
    	print("Baby Gin")
    else: print("Lose")	
    ```
    
- 자주 나오는 실수
    - 정렬한 뒤 앞뒤를 끊어서 확인할 수 있지만, 123123같은 경우는 오히려 실패할 수 있다.
    - 탐욕 알고리즘 적인 접근은 해답을 얻어내지 못하는 경우도 존재함.
- 실습2
    
    ```python
    #최대값의 idx, 동일값이 있을 경우 가장 마지막.
    N = int(input())
    arr = list(map(int, input().split()))
    maxIdx = 0
    for i in range(1,N):
    	if arr[maxIdx] <= arr[i]:
    		maxIdx = i
    
    print(maxIdx)
    ```