1. Built-in 함수와 메서드

   ```py
   Alist = [7,3,9,1,5]
   일 때, 
   Alist.sort()는 원본 Alist를 순차정렬합니다.
   따라서 이후 print(Alist)를 하면 정렬된 리스트 [1,3,5,7,9]가 나옵니다.
   하지만 print(Alist.sort())를 하면 None이 나옵니다.
   해당 메서드는 어떠한 값을 반환하는 것이 아니기 때문입니다.
   
   반대로 sorted(Alist)는 정렬된 리스트값을 반환하기에
   print(sorted(Alist))는 정렬된 리스트값인 [1,3,5,7,9]를 출력합니다.
   하지만 원본 리스트를 변화시킨게 아니므로, print(Alist)의 값은 기존과 같은
   [7,3,9,1,5]가 나옵니다.
   ```

   

2. .extend()와 .append()

   ```python
   A = ['a','b','c']이라고 할 때,
   A.append('?')를 통해 A에 '?'라고 하는 새로운 원소를 맨 뒤에 추가할 수 있습니다.
   이는 A.extend('?') 역시 마찬가지이지만, 추가할 원소의 양이 늘어나면 차이가 발생합니다.
   .append()는 오직 단일 요소만 입력받습니다. 따라서 리스트 등의 형태는 에러가 발생합니다.
   그러나.extend()는 iterable한 요소를 입력받으면 입력값 안의 요소들을 순회하며 각각을 리스트에 추가합니다.
   
   따라서 A에 'ssafy'를 추가할 때,
   A.append('ssafy')는 ['a','b','c','ssafy']인 반면
   A.extend('ssafy')는 ['a','b','c','s','s','a','f','y']가 됩니다.
   
   ```

3. 복사가 잘 된 건가?

   ```python
   a = [1,2,3,4,5]에서 a는 리스트 [1,2,3,4,5]가 담긴 주소를 할당받습니다.
   b = a 를 통해 b 역시 같은 주소에 있는 리스트를 할당 받았습니다.
   이 떄, a[2] = 5를 통해 주소에 담긴 리스트가 [1,2,5,4,5]로 변화합니다
   따라서 print(a)는 [1,2,5,4,5]를 출력하며,
   a와 같은 주소를 사용하던 b 역시 같은 값을 출력하게 됩니다.
   b는 동일한 값의 별도의 리스트를 할당 받은게 아닌,
   a와 같은 주소에 있는 리스트를 할당 받았기 때문에 a를 통해 리스트가 변화하면
   b를 통해 불러오는 리스트 역시 동일하게 변화합니다.
   ```
